<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
	xmlns:util="http://www.springframework.org/schema/util"
	xmlns:p="http://www.springframework.org/schema/p"
	xmlns:c="http://www.springframework.org/schema/c"
	xsi:schemaLocation="
        http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.1.xsd
        http://www.springframework.org/schema/util http://www.springframework.org/schema/util/spring-util-3.1.xsd">

	<!--  where the lucene indexes are stored -->
	<bean id="lucene_directory" class="java.lang.String">
		<constructor-arg value="target/deduplicator"/>
	</bean> 

	<!-- Input and output files -->
	<!--  This is the file that is stored in Lucene, it is the "reference file" -->
	<bean id="storefile" class="java.io.File">
		<constructor-arg value="data/ipni-cyperaceae.tab" />
	</bean>

	<!--  This is the file that is matched against the one stored in Lucene,
		and typically contains fewer records 
		-->
	<bean id="iteratefile" class="java.io.File">
		<constructor-arg value="data/wcs-cyperaceae.tab" />
	</bean>

	<!--  A simple output file of id1:id2 match pairs -->
	<bean id="outputfile" class="java.io.File">
		<constructor-arg value="data/ipni-wcs-match-output.txt" />
	</bean>
	<!--  A simple report file that shows on which fields the matched records differ -->
	<bean id="reportfile" class="java.io.File">
		<constructor-arg value="data/ipni-wcs-match-report.txt" />
	</bean>

	<!-- Matchers:
		These define how two values should be considered matches -->

	<bean id="exactMatcher" class="org.kew.shs.dedupl.matchers.ExactMatcher" />
	
	<bean id="alwaysMatchingMatcher" class="org.kew.shs.dedupl.matchers.AlwaysMatchingMatcher"/>
	
	<bean id="levenshteinMatcher" class="org.kew.shs.dedupl.matchers.LevenshteinMatcher" 
		p:maxDistance="1">
		<!--  Simple example of how a map of "false positives" could work. 
		It would be a vast improvement if these could be submitted using a regexp so that 
		you could specify macro* / micro* rather than every permutation eg: 
		microphylla/macrophylla, micrantha/macrantha, microstachys/macrostachys etc -->
		<property name="falsePositives">
			<util:map>
				<entry key="alta" value="alba"/>
				<entry key="annulatus" value="angulatus"/>
				<entry key="ferox" value="ferax"/>
				<entry key="flabellata" value="flagellata"/>
				<entry key="lactiflora" value="latiflora"/>
				<entry key="latissima" value="laxissima"/>
				<entry key="longispica" value="longispina"/>
				<entry key="parciflora" value="pauciflora"/>
				<entry key="platensis" value="pratensis"/>
				<entry key="stricta" value="striata"/>
			</util:map>
		</property>
	</bean>

	<bean id="ocrCanonicaliserMatcher" class="org.kew.shs.dedupl.matchers.OcrCanonicaliserMatcher" />

	<bean id="epithetMatcher" class="org.kew.shs.dedupl.matchers.CompositeAnyMatcher">
		<property name="matchers">
			<util:list>
				<ref bean="levenshteinMatcher"/>
				<ref bean="ocrCanonicaliserMatcher"/>
			</util:list>
		</property>
	</bean>	
	
	<bean id="commonTokensMatcher" class="org.kew.shs.dedupl.matchers.CommonTokensMatcher" 
		p:minRatio="0.5"/>

	<bean id="authorCommonTokensMatcher" class="org.kew.shs.dedupl.matchers.AuthorCommonTokensMatcher" 
		p:minRatio="0.5"/>

	<bean id="capitalLettersMatcher" class="org.kew.shs.dedupl.matchers.CapitalLettersMatcher" 
		p:minRatio="0.5"/>

	<bean id="numberMatcher" class="org.kew.shs.dedupl.matchers.NumberMatcher" 
		p:minRatio="0.5"/>

	<bean id="ngramMatcher" class="org.kew.shs.dedupl.matchers.NGramMatcher" 
		p:minRatio="0.5" p:nGramLength="2"/>
	
	<bean id="yearMatcher" class="org.kew.shs.dedupl.matchers.InitialSubstringMatcher" 
		p:prefixSize="3"/>

	<!-- Transformers: 
		These carry out defined transformations to clean values before storage -->
	<bean id="genusCleaner"
		class="org.kew.shs.dedupl.transformers.StripNonAlphabeticCharactersTransformer" />

	<bean id="epithetCleaner"
		class="org.kew.shs.dedupl.transformers.EpithetTransformer" />

	<bean id="collationAndYearCleaner" 
		class="org.kew.shs.dedupl.transformers.CompositeTransformer">
		<property name="transformers">
			<util:list id="1">
				<bean id="icollationCleaner" 
					class="org.kew.shs.dedupl.transformers.StripNonNumericCharactersTransformer" />
				<bean id="rcollationCleaner" 
					class="org.kew.shs.dedupl.transformers.RomanNumeralTransformer" />
				<!--ref bean="icollationCleaner"/>
				<ref bean="rcollationCleaner"/-->
			</util:list>
		</property>
	</bean>
		

	<!-- Column based properties, these define: column index of the property 
		in the input file, how these should be cleaned prior to storage (using 
		references to transformers as defined above), if they should 
		be used in the select to find possible matches, how these should match 
		(using references to matchers as defined above) -->
	<util:list id="columnProperties">
		<bean class="org.kew.shs.dedupl.configuration.Property" 
			p:name="family"
			p:columnIndex="1"
			p:matcher-ref="exactMatcher"
			p:useInSelect="false"/>
		<bean class="org.kew.shs.dedupl.configuration.Property" 
			p:name="fullName"
			p:columnIndex="2"
			p:matcher-ref="alwaysMatchingMatcher"
			p:useInSelect="false"/>			
		<bean class="org.kew.shs.dedupl.configuration.Property"
			p:name="genus"
			p:columnIndex="3"
			p:matcher-ref="exactMatcher"
			p:transformer-ref="genusCleaner"
			p:useInSelect="true"/>
		<bean class="org.kew.shs.dedupl.configuration.Property"
			p:name="species"
			p:columnIndex="4"
			p:matcher-ref="epithetMatcher"
			p:transformer-ref="epithetCleaner"
			p:useInSelect="true"
			p:indexLength="true"
			p:indexInitial="true"/>
		<bean class="org.kew.shs.dedupl.configuration.Property"
			p:name="basionymAuthor"
			p:columnIndex="5"
			p:matcher-ref="authorCommonTokensMatcher"
			p:blanksMatch="true"/>
		<bean class="org.kew.shs.dedupl.configuration.Property"
			p:name="author"
			p:columnIndex="6"
			p:matcher-ref="authorCommonTokensMatcher"/>
		<bean class="org.kew.shs.dedupl.configuration.Property"
			p:name="collationAndYear"
			p:columnIndex="7"
			p:matcher-ref="numberMatcher"
			p:transformer-ref="collationAndYearCleaner"
			p:blanksMatch="true"/>
		<bean class="org.kew.shs.dedupl.configuration.Property"
			p:name="publication"
			p:columnIndex="8"
			p:matcher-ref="alwaysMatchingMatcher"/>
	</util:list>

	<bean id="config" class="org.kew.shs.dedupl.configuration.MatchConfiguration"
		p:storeFile-ref="storefile"
		p:iterateFile-ref="iteratefile"
		p:inputFileDelimiter="\t"
		p:outputFileDelimiter=":"
		p:outputFile-ref="outputfile"
		p:properties-ref="columnProperties"
		p:loadReportFrequency="5000"
		p:writeComparisonReport="true"
		p:reportFile-ref="reportfile"/>

</beans>