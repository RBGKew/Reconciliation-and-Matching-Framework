<div xmlns:jsp="http://java.sun.com/JSP/Page"
	xmlns:fn="http://java.sun.com/jsp/jstl/functions"
	xmlns:c="http://java.sun.com/jsp/jstl/core"
	xmlns:spring="http://www.springframework.org/tags" version="2.0">
	<c:set var="req" value="${pageContext.request}" />
	<c:set var="serverAndPort" value="${req.serverName}"/>
	<c:if test="${req.localPort != 80}">
		<c:set var="serverAndPort" value="${req.serverName}:${req.localPort}"/>
	</c:if>
	<spring:url var="base" value="/"/>

	<h1>About Reconciliation</h1>

	<p>
		<em>Reconciliation</em> is the semi-automated process of matching text
		strings (like <i>Quercus alba</i> L.) to entities in databases (like
		<code>IPNI 295763-1</code>,
		<code>http://ipni.org/urn:lsid:ipni.org:names:295763-1</code> or
		<code>http://www.theplantlist.org/tpl1.1/record/kew-171499</code>).
	</p>

	<p>
		<em>Open Refine</em> (previously called <em>Google Refine</em>)
		is a tool that can be used to do this.  It can query a
		<em>Web Service</em> — a website that returns information in a
		form the computer can interpret — and record the results,
		whether that’s an exact match, a close match, a list of possible
		matches, or no match at all.
	</p>

	<h1>About Kew’s Reconciliation Services</h1>

	<p>
		Kew provides several reconciliation services, according to the type of
		entity (name, publication etc) and the underlying data source.  At
		present, these include <em>IPNI</em> and <em>The Plant List</em>.  The <em>World
		Checklist</em> may be added later. Once The Plant List and the World
		Checklist have themselves been fully reconciled to IPNI (implying that
		any missing names have been added to IPNI) it will usually be
		appropriate to reconcile only to IPNI.
	</p>

	<h2>Using Kew’s Reconciliation Services with Open Refine</h2>

	<h3>Software overview and installation</h3>

	<p>
		Watch the three introductory videos — these instructions assume some familiarity
		with Open Refine.  There’s also <a href="http://openrefine.org/documentation.html">written
		documentation</a>.</p>

	<ul>
		<li><a href="https://www.youtube.com/watch?v=B70J_H_zAWM">General introduction, editing messy data</a></li>
		<li><a href="https://www.youtube.com/watch?v=cO8NVCs_Ba0">Transforming semi-structured data into properly structured data</a></li>
		<li><a href="https://www.youtube.com/watch?v=5tsyz3ibYzk">Calling a web service to supplement the dataset, reconciliation</a></li>
	</ul>

	<p>
		Download Open Refine from <a href="http://openrefine.org/download.html">the download page</a>,
		choose the development version, currently <code>2.6-beta1</code>.
	</p>

	<h3>Data preparation</h3>

	<p>
		The services can cope with names recorded in a single column, like
		<code>Quercus alba L.</code> or
		<code>Quercus alba f. latiloba Sarg.</code>, but for better results split the data into a single column
		for each necessary part (e.g. generic epithet, species epithet, publication title etc).
		You can use Open Refine to do this — see the videos — or any other program.
	</p>

	<p>
		Optionally, use facets to limit which names you wish to match
		— for example, to select particular ranks to match (TPL
		doesn’t include any ranks above species, and the Reconciliation
		Service doesn’t yet support anything above genus).
	</p>

	<p>
		If you have a lot of names (over 1000) you could star 10 or so
		names and facet on them, for a trial run.
	</p>

	<p>
		<spring:url var="about" value="/about" />
		Find the configuration you want to use from the <a href="${about}">list here</a>.
		Note the two <em>endpoints</em>: the Open Refine reconciliation service, and the
		<abbr title="JavaScript Object Notation">JSON</abbr> web service.  These instructions
		will assume you have a list of plant names and wish to reconcile them against the
		<spring:url var="aboutStandardTpl" value="/about/StandardTplNameMatch" />
		<a href="${aboutStandardTpl}">Standard TPL Name Match</a> service.
	</p>

	<h3>Querying the web service</h3>

	<spring:url var="reconcileUrl" value="/reconcile/StandardTplNameMatch" />

	<p>There are two options for querying the Reconciliation Service:</p>

	<h4>Querying as an Open Refine Reconciliation Service</h4>

	<p>
		This has a better user interface for choosing between multiple
		matches, but it’s more difficult to access derived data, like
		whether a reconciled name is known to be a synonym.
	</p>

	<ol>
		<li>
			If you have whole entities (e.g. full scientific names) in a single column,
			choose that column
		</li>
		<li>
			Otherwise, choose the “main” column — the first in the list given on the
			page describing the service, in this case <code>genus</code>
		</li>
		<li>
			Click the column heading, and choose <em>Reconcile</em> → <em>Start
			reconciling…</em>.
		</li>
		<li>
			If this is the first time you’ve reconciled against a
			particular service, you will need to click <em>Add Standard
			Service</em>. Enter the URL from the Reconciliation Service website,
			for example <code>${reconcileUrl}</code>,
			and click OK.
		</li>
		<li>
			Select the service from the list on the left. After a
			moment, the dialog is filled in with options.
		</li>
		<li>
			If you have columns for genus, species etc fill in the text
			boxes for <em>Also use relevant details from other columns</em>.
			The values to fill in come from those listed on the website
			describing the service (in this case, <code>genus</code>, <code>species</code>
			etc).<br />
			<spring:url var="img" value="/img/reconciling-select-properties.png"/>
			<img src="${img}" alt="" />
		</li>
		<li>
			Click <em>Start Reconciling</em>
		</li>
		<li>
			Results appear after a while. Where there’s a single
			possibility it will have been automatically selected. Otherwise,
			you can select the match using the tick boxes.<br />
			<spring:url var="img" value="/img/reconciling-results.png"/>
			<img src="${img}" alt="" />
		</li>
		<li>
			If matching hasn’t worked you can also click <em>Search
			for match</em> and adjust the query.<br />
			<spring:url var="img" value="/img/reconciling-suggest-entity.png"/>
			<img src="${img}" alt="" />
		</li>
		<li>
			To get the identifiers: click the column, choose <em>Add column based on this column…</em>
			and use the expression <code>cell.recon.match.id</code>.  To get the name
			use <code>cell.recon.match.name</code> instead.
		</li>
	</ol>

	<h4>Querying as a standard web service</h4>

	<p>
		This requires fewer steps to retrieve additional data returned
		by the web service (e.g. taxomic status from TPL), but
		you must have your names split into columns, and
		it requires writing some computer code.
	</p>

	<ol>
		<spring:url var="jsonBase" value="/match/StandardTplNameMatch" />
		<spring:url var="jsonExample" value="/match/StandardTplNameMatch?genus=Quercus&amp;species=alba&amp;authors=L." />
		<li>
			Click a column heading and choose <em>Edit column</em> → <em>Add
			column by fetching URLs</em>
		</li>
		<li>
			Give the column a name, and set the <code>Throttle delay</code> to zero.
		</li>
		<li>
			Use one of the query expressions below, replacing <code>Genus</code>,
			<code>Species</code> etc with the column headings from your
			dataset. This constructs a URL like <a href="${jsonExample}">this</a>
			(which you can click on to see the web service response, in <abbr
			title="JavaScript Object Notation">JSON</abbr> format).
			<pre>
<code>"http://${serverAndPort}${jsonBase}?genus="+row.cells["Genus"].value.escape('url')
+forNonBlank(row.cells["Species"].value, v, "&amp;species="+v.escape('url'), "")
+forNonBlank(row.cells["InfraSpecies"].value, v, "&amp;infraspecies="+v.escape('url'), "")
+forNonBlank(row.cells["InfraAuthor"].value, v, "&amp;authors="+v.escape('url'),
	forNonBlank(row.cells["SpeciesAuthor"].value, v, "&amp;authors="+v.escape('url'), "")
)</code></pre>

			<spring:url var="img" value="/img/reconciling-add-with-webservice.png"/>
			<img src="${img}" alt="" />
		</li>

		<li>
			Results are returned in [<abbr title="JavaScript Object Notation">JSON</abbr>]
			format, and might look something like this (but all on one line):
			<pre><code>[
	{
		"species": "alba",
		"authors_transf": "l",
		"genus": "Quercus",
		"taxonomicStatus": "Accepted",
		"genus_transf": "Querca",
		"species_transf": "alba",
		"id": "kew-171499",
		"authors": "L.",
		"acceptedNameID": "kew-171499",
		"acceptedNameID_transf": "kew-171499",
		"infraspecies_transf": "",
		"infraspecies": "",
		"taxonomicStatus_transf": "Accepted"
	}
]</code></pre>

			In <abbr title="JavaScript Object Notation">JSON</abbr> terms,
			that’s an array (i.e. a list, denoted by <code>[ ... ]</code>)
			containing objects (i.e. “things”, that’s the <code>{ ... }</code>) with properties
			(<code>"a": "b"</code>).
		</li>

		<li>
			Probably most match results only contain a single match. You can
			check this (and facet on the result) by making a new column out of
			the match result:
			<pre><code>parseJson(value).length()</code></pre>
		</li>

		<li>
			Perhaps after faceting for match results containing only
			one name, properties of interest can be extracted. Add another
			column:

			<pre><code>parseJson(value)[0].id</code></pre>

			(The <code>[0]</code>
			means the “zeroth” object in the list, programming
			languages often count from zero, like floors in buildings. The
			<code>.id</code>
			chooses which property to extract.  With this TPL reconciliation
			choose <code>.taxonomicStatus</code> to retrieve
			the accepted/synonym/etc status from TPL.)
		</li>

		<li>
			You can also do more complicated things:

			<pre><code>with (parseJson(value)[0],
      m,
      if (m.taxonomicStatus == "Accepted",
          "Accepted",
          m.taxonomicStatus + " of " + m.acceptedNameID
      )
)</code></pre>

			See the <a href="https://github.com/OpenRefine/OpenRefine/wiki/GREL-Functions">GREL Functions Documentation</a>
			for more information.
		</li>
	</ol>

	<h3>Using the results</h3>

	<p>
		Either way, you can then export the results into CSV (or other
		standard formats) using the <em>Export</em> menu.
	</p>

	<h3>Troubleshooting</h3>

	<p>
		This section will be completed as we discover problems — <a href="mailto:M.Blissett@kew.org?subject=Reconciliation%20service">please let us know!</a>.
		Allocating more memory may help, refer to the <a href="https://github.com/OpenRefine/OpenRefine/wiki/FAQ:-Allocate-More-Memory">OpenRefine documentation</a> on this.
	</p>

	<h3>Advanced data preparation / manipulation</h3>

	<p>
		It's possible to use some of the transformers that are behind these reconciliation services to prepare your data.  For example, you may wish to
		extract a year out of a field containing a whole reference.  See the <a href="https://github.com/RBGKew/String-Transformers#string-transformers">String Transformers</a> project
		for how to do this.
	</p>
</div>
